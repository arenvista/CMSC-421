# Question
You will need to create a Linux C shell program in project 1.  To prepare for the project, conduct research on C shells.  Examples may be to search for articles or examine a program example of a C shell. 

Write a brief summary of what steps you took and what you learned.  This summary should be a maximum of two paragraphs or 10 bullet points (maximum around 250 words, less is fine).  Thoughtful, concise writing will earn the maximum points.

Short sentences are good.  Clear, easy to read writing is the goal. Throughout this course you will need to write brief summaries.  The quality of your writing will impact your scores.

If you have created a vm, you can start coding a c shell on your vm. Do not to use the fork( ) system call on your laptop.  Only use the fork( ) system call in a vm.

# Response

A Unix shell is a command-line **interpreter** that allows **users** to interface with the Unix operating system and Unix-like systems. [Link](https://wiki.archlinux.org/title/Command-line_shell)

Personally, I have used Bash, fish, tcsh, and currently am using zsh on my laptop.

Common requirements for a shell include a REPL, exit, echo, the ability to **execute** programs, and a means of navigating the file system (ideally including absolute and relative paths). There should also be a way to direct stdout and stderr. Most (if not all) modern shells will also include a means of navigating history and a means of writing history and managing the **persistence** of history across instances. [Link](https://app.codecrafters.io/courses/shell/overview)

When building our own shell in Linux using C, we will **inevitably** run into the `fork()` function. In Linux, `fork()` is what allows a shell to create new processes for the commands to run. 

Note: [Operating Systems 3-Easy Pieces]
> * **Definition:** A process is simply a **running program**.
> * **Program vs. Process:**
>      * *Program:* Lifeless bytes sitting on a disk (instructions, static data).
>      * *Process:* The OS executes those bytes, turning them into active tasks.

All processes, except the **initial** process (init), are generated from some parent `fork()` call. This can be traced all the way back to the **initial** process which is **initialized** by the kernel. [Link](https://dev.to/villyp/building-a-shell-in-c-using-fork-and-process-management-5nb)

`fork()` works by duplicating the current running **process**. Say we call `ls`, the shell will:
1. Duplicate using `fork()`, creating a parent and child.
2. The child gets a copy of the **environment** and a different PID.
    - Though `fork()` returns `0` *in the child* and the child's PID is returned *in the parent*.
3. The child replaces its memory with the `ls` program using `execvp()`.

The reason for this **implementation** is to **separate** processes; thus, if anything does go wrong, **only the child is affected**.

## Example of ls *(from article)*
```c
pid_t pid = fork();
if (pid == 0) { // Child process
    execvp(args[0], args); // Run the given command (e.g., "ls")
    perror("exec failed"); // Only reached if exec fails
    exit(1);
} else if (pid > 0) { // Parent process
    // You'll want to track your jobs using an array
    add_job(pid)

    int status;
    waitpid(pid, &status, 0); // Wait for the child to finish
    printf(WIFEXITED(status) ? "Success\n" : "Failure\n");
} else {
    perror("fork failed"); // Handle fork error
}
```

Note: shells use *signals* for a lot of different tasks:
- `SIGINT` is the classic way we interrupt a process (commonly Ctrl-C)
- `SIGTSTP` to stop a process
- `SIGCONT` to resume a stopped process

These highlight some of the first steps and concepts that are essential towards developing our own shell.
